package Ph2_CSC212;

public class AVLTree<T> {

    private AVLNode<T> root, current;

    public AVLTree() {
        current = root = null;
    }

    public boolean empty() {
        return root == null;
    }

    public boolean full() {
        return false;
    }

    public T retrieve() {
        return current.data;
    }

    // ===================== FIND =====================
    public boolean findKey(int k) {

        AVLNode<T> p = root;
        while (p != null) {

            current = p;

            if (k == p.key)
                return true;

            else if (k < p.key)
                p = p.left;

            else
                p = p.right;
        }
        return false;
    }

    // ===================== INSERT (AVL) =====================
    public boolean insert(int key, T val) {

        if (findKey(key)) return false;

        root = AVLInsert(root, key, val);
        current = root;
        return true;
    }

    private AVLNode<T> AVLInsert(AVLNode<T> node, int key, T val) {

        if (node == null)
            return new AVLNode<T>(key, val);

        if (key < node.key)
            node.left = AVLInsert(node.left, key, val);
        else
            node.right = AVLInsert(node.right, key, val);

        return updateBalance(node);
    }

    // ===================== DELETE (AVL) =====================
    public boolean removeKey(int key) {

        if (!findKey(key)) return false;

        root = AVLDelete(root, key);
        current = root;
        return true;
    }

    private AVLNode<T> AVLDelete(AVLNode<T> node, int key) {

        if (node == null)
            return null;

        // BST delete
        if (key < node.key) {
            node.left = AVLDelete(node.left, key);
        }
        else if (key > node.key) {
            node.right = AVLDelete(node.right, key);
        }
        else { // Found

            // Case 1: one child / no children
            if (node.left == null)
                return node.right;
            if (node.right == null)
                return node.left;

            // Case 2: two children
            AVLNode<T> min = node.right;
            while (min.left != null)
                min = min.left;

            node.key = min.key;
            node.data = min.data;

            node.right = AVLDelete(node.right, min.key);
        }

        return updateBalance(node);
    }

    // ===================== TRAVERSAL =====================
    public void inOrder() {

        if (root == null)
            System.out.println("empty tree");
        else
            inOrder(root);
    }

    private void inOrder(AVLNode<T> p) {

        if (p == null) return;

        inOrder(p.left);
        System.out.println("key = " + p.key + " , data = " + p.data);
        inOrder(p.right);
    }

    public AVLNode<T> getRoot() {
        return root;
    }

    // ===================== HEIGHT + BALANCE =====================

    private int height(AVLNode<T> node) {
        if (node == null) return -1;
        return 1 + Math.max(height(node.left), height(node.right));
    }

    private int balance(AVLNode<T> node) {
        if (node == null) return 0;
        return height(node.right) - height(node.left);
    }

    // ===================== ROTATION LOGIC =====================

    private AVLNode<T> updateBalance(AVLNode<T> node) {

        int bf = balance(node);

        // Right heavy
        if (bf > 1) {
            if (balance(node.right) >= 0)
                return rotateLeftLeft(node);   // RR
            else
                return rotateRightLeft(node);  // RL
        }

        // Left heavy
        if (bf < -1) {
            if (balance(node.left) <= 0)
                return rotateRightRight(node); // LL
            else
                return rotateLeftRight(node);  // LR
        }

        return node;
    }

    // LL rotation
    private AVLNode<T> rotateLeftLeft(AVLNode<T> node) {

        AVLNode<T> a = node.left;
        AVLNode<T> b = a.right;

        a.right = node;
        node.left = b;

        return a;
    }

    // RR rotation
    private AVLNode<T> rotateRightRight(AVLNode<T> node) {

        AVLNode<T> a = node.right;
        AVLNode<T> b = a.left;

        a.left = node;
        node.right = b;

        return a;
    }

    // LR rotation
    private AVLNode<T> rotateLeftRight(AVLNode<T> node) {

        node.left = rotateRightRight(node.left);
        return rotateLeftLeft(node);
    }

    // RL rotation
    private AVLNode<T> rotateRightLeft(AVLNode<T> node) {

        node.right = rotateLeftLeft(node.right);
        return rotateRightRight(node);
    }
}
