package csc212_phase2;


 
public class AVLTree<T> { 
	
    public int size;
    public AVLNode<T> root, current; 
 

    public AVLTree() {
        current = root = null; 
        size = 0;
    } 

    public boolean empty() {
        return root == null;
    }

    public boolean full() {
        return false; 
    }

    // ===================== RETRIEVE =====================
    public T retrieve() {
        return current.data;
    }

    // ===================== UPDATE =====================
    public void update(T e) {
        if (current != null)
            current.data = e;
    } 

    
    // ===================== SEARCH =====================
    public T search(int key) {
        AVLNode<T> p = root;

        while (p != null) {
            if (key == p.key) {
                current = p; 
                return p.data;
            }
            else if (key < p.key)
                p = p.left;
            else
                p = p.right;
        }
        return null;
    }
    

    // ===================== FIND KEY =====================
    public boolean findKey(int k) {

        AVLNode<T> p = root;
        while (p != null) {

            current = p;

            if (k == p.key)
                return true;

            else if (k < p.key)
                p = p.left;

            else
                p = p.right;
        }
        return false;
    }

    // ===================== INSERT (AVL) =====================
    public boolean insert(int key, T val) {
 
        if (findKey(key)) return false;

        root = AVLInsert(root, key, val);
        size++;
        current = root;
        return true;
    }

    private AVLNode<T> AVLInsert(AVLNode<T> node, int key, T val) {

        if (node == null)
            return new AVLNode<T>(key, val);

        if (key < node.key)
            node.left = AVLInsert(node.left, key, val);
        else
            node.right = AVLInsert(node.right, key, val);

        return updateBalance(node);
    }

    // ===================== DELETE (AVL) =====================
    public boolean removeKey(int key) {

        if (!findKey(key)) return false;

        root = AVLDelete(root, key);
        size--;
        current = root;
        return true;
    }

    private AVLNode<T> AVLDelete(AVLNode<T> node, int key) {

        if (node == null)
            return null;

        // BST delete
        if (key < node.key) {
            node.left = AVLDelete(node.left, key);
        }
        else if (key > node.key) {
            node.right = AVLDelete(node.right, key);
        }
        else { // Found

            // Case 1: one child / no children
            if (node.left == null)
                return node.right;
            if (node.right == null)
                return node.left;

            // Case 2: two children
            AVLNode<T> min = node.right;
            while (min.left != null)
                min = min.left;

            node.key = min.key;
            node.data = min.data;

            node.right = AVLDelete(node.right, min.key);
        }

        return updateBalance(node);
    }

    // ===================== TRAVERSAL =====================
    public void inOrder() {

        if (root == null)
            System.out.println("empty tree");
        else
            inOrder(root);
    }

    private void inOrder(AVLNode<T> p) {

        if (p == null) return;

        inOrder(p.left);
        System.out.println("key = " + p.key + " , data = " + p.data);
        inOrder(p.right);
    }

    public AVLNode<T> getRoot() {
        return root;
    }
    
    public LinkedList<T> inOrdertraverseData() {
        LinkedList<T> list = new LinkedList<T>();
        inOrderCollect(root, list);
        return list;
    }

    private void inOrderCollect(AVLNode<T> node, LinkedList<T> list) {
        if (node == null) return;

        inOrderCollect(node.left, list);
        list.insert(node.data);
        inOrderCollect(node.right, list);
    }



    // ===================== HEIGHT + BALANCE FACTOR =====================
    private int height(AVLNode<T> node) {
        return (node == null ? -1 : node.height);
    }

    private int getBF(AVLNode<T> node) {
        if (node == null) return 0;
        return height(node.right) - height(node.left);
    }


    // ===================== ROTATION + BALANCE UPDATE =====================

    private AVLNode<T> updateBalance(AVLNode<T> node) {

        // Update height (O(1))
        node.height = 1 + Math.max(height(node.left), height(node.right));

        // Compute BF
        int bf = height(node.right) - height(node.left);

        // Update enum balance
        if (bf > 0)
            node.bal = Balance.PlusOne;
        else if (bf < 0)
            node.bal = Balance.MinusOne;
        else
            node.bal = Balance.Zero;

        //Balance cases
        if (bf > 1) {
            // Right heavy
            if (height(node.right.right) >= height(node.right.left))
                return rotateRightRight(node);  // RR
            else
                return rotateRightLeft(node);   // RL
        }

        if (bf < -1) {
            // Left heavy
            if (height(node.left.left) >= height(node.left.right))
                return rotateLeftLeft(node);   // LL
            else
                return rotateLeftRight(node);  // LR
        }

        return node;
    }



    // LL rotation
    private AVLNode<T> rotateLeftLeft(AVLNode<T> node) {
        AVLNode<T> a = node.left;
        AVLNode<T> b = a.right;

        a.right = node;
        node.left = b;

        // UPDATE HEIGHTS
        node.height = 1 + Math.max(height(node.left), height(node.right));
        a.height = 1 + Math.max(height(a.left), height(a.right));

        return a;
    }


    // RR rotation
    private AVLNode<T> rotateRightRight(AVLNode<T> node) {
        AVLNode<T> a = node.right;
        AVLNode<T> b = a.left;

        a.left = node;
        node.right = b;

        // UPDATE HEIGHTS
        node.height = 1 + Math.max(height(node.left), height(node.right));
        a.height = 1 + Math.max(height(a.left), height(a.right));

        return a;
    }


    // LR rotation
    private AVLNode<T> rotateLeftRight(AVLNode<T> node) {
        node.left = rotateRightRight(node.left);
        return rotateLeftLeft(node);
    }

    // RL rotation
    private AVLNode<T> rotateRightLeft(AVLNode<T> node) {
        node.right = rotateLeftLeft(node.right);
        return rotateRightRight(node);
    }

    
    

}
